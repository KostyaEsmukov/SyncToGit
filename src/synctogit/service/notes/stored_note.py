import abc
import re
from pathlib import Path
from typing import Dict, Mapping


class StoredNote(abc.ABC):
    note_html_header_fields_marks = (
        b"<!--+++++++++++++-->",
        b"<!----------------->",
    )

    @classmethod
    def _note_to_html(cls, note_header: Mapping[str, str], note_html: bytes) -> bytes:
        header = []
        header += [b"<!doctype html>"]
        header += [b"<!-- PLEASE DO NOT EDIT THIS FILE -->"]
        header += [
            b"<!-- All changes you've done here will be stashed on next sync -->"
        ]
        start_mark, end_mark = cls.note_html_header_fields_marks
        header += [start_mark]
        header.extend(
            b"<!-- %s: %s -->" % (k.encode(), v.encode())
            for k, v in note_header.items()
        )
        header += [end_mark]
        header += [b""]

        for line in header:
            assert b"\n" not in line

        assert not note_html.startswith(b"<!doctype")
        body = b"\n".join(header) + note_html
        return body

    @classmethod
    def _parse_note_header(cls, note_path: Path) -> Dict[str, str]:
        start_mark, end_mark = cls.note_html_header_fields_marks
        # We will compare them with the readline() output, which
        # lines end with a newline.
        start_mark += b"\n"
        end_mark += b"\n"

        line = b"start"  # I'm waiting for PEP-572 eagerly
        result = {}
        with open(str(note_path), "rb") as f:
            # Skip lines before the starting mark
            while line != start_mark and line != b"":
                line = f.readline()

            if line == b"":  # EOF
                raise CorruptedNoteError(
                    "Unable to find the starting mark of the note metadata "
                    "header for %s" % note_path,
                    note_path,
                )

            # Read the actual vars
            line = f.readline()
            while line != end_mark and line != b"":
                g = re.search(b"^<!-- ([a-zA-Z_]+): (.+) -->$", line)
                if g is None:
                    raise CorruptedNoteError(
                        "Expected a metadata variable in the header, but "
                        'it hasn\'t been found in the line "%s" of the note '
                        "%s" % (line.decode().strip(), note_path),
                        note_path,
                    )
                key = g.group(1).decode()
                value = g.group(2).decode()
                result[key] = value
                line = f.readline()

            if line == b"":  # EOF
                raise CorruptedNoteError(
                    "Unable to find the end mark of the note metadata "
                    "header for %s" % note_path,
                    note_path,
                )
        return result


class CorruptedNoteError(ValueError):
    def __init__(self, message, note_path: Path):
        super().__init__(message)
        self.note_path = note_path
