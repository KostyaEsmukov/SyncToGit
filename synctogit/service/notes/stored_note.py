import abc
import re
from pathlib import Path
from typing import Dict, Mapping


class StoredNote(abc.ABC):
    note_html_header_fields_marks = (
        b"<!--+++++++++++++-->",
        b"<!----------------->",
    )

    @classmethod
    def _note_to_html(
        cls,
        note_header: Mapping[str, str],
        note_html: bytes
    ) -> bytes:
        header = []
        header += [b"<!doctype html>"]
        header += [b"<!-- PLEASE DO NOT EDIT THIS FILE -->"]
        header += [b"<!-- All changes you've done here will be stashed on next sync -->"]
        start_mark, end_mark = cls.note_html_header_fields_marks
        header += [start_mark]
        header.extend(
            b"<!-- %s: %s -->" % (k.encode(), v.encode())
            for k, v in note_header.items()
        )
        header += [end_mark]
        header += [b""]

        for line in header:
            assert b'\n' not in line

        assert not note_html.startswith(b'<!doctype')
        body = b'\n'.join(header) + note_html
        return body

    @classmethod
    def _parse_note_header(cls, note_path: Path) -> Dict[str, str]:
        start_mark, end_mark = cls.note_html_header_fields_marks
        # We will compare them with the readline() output, which
        # lines end with a newline.
        start_mark += b'\n'
        end_mark += b'\n'

        line = b'start'  # I'm waiting for PEP-572 eagerly
        result = {}
        with open(str(note_path), 'rb') as f:
            # Skip lines before the starting mark
            while line != start_mark and line != b'':
                line = f.readline()

            if line == b'':  # EOF
                raise CorruptedNoteError(
                    'Unable to find the starting mark of the note metadata '
                    'header for %s' % note_path,
                    note_path
                )

            # Read the actual vars
            line = f.readline()
            while line != end_mark and line != b'':
                g = re.search(b'^<!-- ([a-zA-Z_]+): (.+) -->$', line)
                if g is None:
                    raise CorruptedNoteError(
                        'Expected a metadata variable in the header, but '
                        'it hasn\'t been found in the line "%s" of the note '
                        '%s' % (line.decode().strip(), note_path),
                        note_path
                    )
                key = g.group(1).decode()
                value = g.group(2).decode()
                result[key] = value
                line = f.readline()

            if line == b'':  # EOF
                raise CorruptedNoteError(
                    'Unable to find the end mark of the note metadata '
                    'header for %s' % note_path,
                    note_path
                )
        return result


class CorruptedNoteError(ValueError):
    def __init__(self, message, note_path: Path):
        super().__init__(message)
        self.note_path = note_path
